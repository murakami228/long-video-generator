import fs from 'fs';
import path from 'path';
import 'dotenv/config';
import OpenAI from 'openai';
import { execSync } from 'child_process';

// Initialize OpenAI
const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
});

const projectSlug = process.argv[2];
if (!projectSlug) {
    console.error("Please provide a project slug. Usage: npx tsx scripts/build.ts <project_slug>");
    process.exit(1);
}

const projectDir = path.join(process.cwd(), 'projects', projectSlug);
const assetsDir = path.join(projectDir, 'assets');
const inputFile = path.join(projectDir, 'input.json');
const outputFile = path.join(projectDir, 'data.json');

if (!fs.existsSync(projectDir)) {
    console.error(`Project directory not found: ${projectDir}`);
    process.exit(1);
}
if (!fs.existsSync(assetsDir)) {
    fs.mkdirSync(assetsDir, { recursive: true });
}

// Read Input
let inputData: any = {};
if (fs.existsSync(inputFile)) {
    inputData = JSON.parse(fs.readFileSync(inputFile, 'utf-8'));
} else {
    console.error(`input.json not found in ${projectDir}`);
    process.exit(1);
}

async function main() {
    console.log(`Building project: ${projectSlug}`);

    let scriptData = inputData.customScript;

    // AI Generation Logic (Placeholder for future: if (!scriptData) { ... call GPT ... })
    // For now, we assume customScript is present or we fallback to dummy if pure topic.

    if (!scriptData) {
        console.log("No custom script found. Future: Generate from topic via GPT.");
        // Fallback for demo if needed, or error out.
        // For this refactor, we focus on the migrated Custom Script V2.
        process.exit(1);
    }

    // Asset Generation (Mock or Real)
    // 1. Audio (TTS)
    console.log("Generating Audio...");
    let audioUrl = "";
    const voicePath = path.join(assetsDir, "voice.mp3");

    try {
        if (!fs.existsSync(voicePath)) {
            console.log("Calling OpenAI TTS...");
            const fullScript = scriptData.sections.map((s: any) => s.text).join(" ");
            const mp3 = await openai.audio.speech.create({
                model: "tts-1",
                voice: "alloy",
                input: fullScript,
            });
            const buffer = Buffer.from(await mp3.arrayBuffer());
            fs.writeFileSync(voicePath, buffer);
            console.log("Generated voice.mp3");
        } else {
            console.log("Using existing voice.mp3");
        }

        // Copy to public
        const publicAssetsDir = path.join(process.cwd(), 'public', 'generated_assets', projectSlug);
        if (!fs.existsSync(publicAssetsDir)) fs.mkdirSync(publicAssetsDir, { recursive: true });

        const publicVoicePath = path.join(publicAssetsDir, "voice.mp3");
        fs.copyFileSync(voicePath, publicVoicePath);

        audioUrl = `/generated_assets/${projectSlug}/voice.mp3`;

    } catch (error) {
        console.error("Audio generation failed:", error);
    }

    // 2. Captions
    console.log("Processing Captions...");
    const captions = scriptData.sections.map((s: any) => ({
        text: s.text,
        startMs: s.start,
        endMs: s.end
    }));

    // 3. Images
    console.log("Mapping Images (Agent-Generated)...");
    const scenes = [];

    // In this "Agent-Driven" mode, we expect images to be pre-generated by Antigravity
    // and placed in `projects/{slug}/assets/`.
    // Naming convention: `scene_{index}_{startTime}.png`

    // Add Title Scene
    let titleImgUrl = "https://placehold.co/1080x1920/000000/FFFFFF/png?text=Title+Scene";
    const titleAssetPath = path.join(assetsDir, "title.png");

    if (fs.existsSync(titleAssetPath)) {
        console.log(`[Title Asset Found] Using existing: title.png`);
        const publicAssetsDir = path.join(process.cwd(), 'public', 'generated_assets', projectSlug);
        if (!fs.existsSync(publicAssetsDir)) fs.mkdirSync(publicAssetsDir, { recursive: true });

        const publicPath = path.join(publicAssetsDir, "title.png");
        fs.copyFileSync(titleAssetPath, publicPath);
        titleImgUrl = `/generated_assets/${projectSlug}/title.png`;
    }

    scenes.push({
        text: "Title",
        imageUrl: titleImgUrl,
        highlight: [],
        durationInFrames: 150
    });

    for (let i = 0; i < scriptData.sections.length; i++) {
        const s = scriptData.sections[i];
        const duration = Math.ceil((s.end - s.start) / 1000 * 30);
        const keyword = s.visual ? s.visual.split(' ')[0] : "excel";

        // Expected Filename
        const safeName = `scene_${i}_${Math.floor(s.start)}.png`;
        const localAssetPath = path.join(assetsDir, safeName);

        let imgUrl = "";

        if (fs.existsSync(localAssetPath)) {
            console.log(`[Asset Found] Using existing: ${safeName}`);

            // Copy to public for preview
            const publicAssetsDir = path.join(process.cwd(), 'public', 'generated_assets', projectSlug);
            if (!fs.existsSync(publicAssetsDir)) fs.mkdirSync(publicAssetsDir, { recursive: true });

            const publicPath = path.join(publicAssetsDir, safeName);
            // Verify if copy needed (overwrite for safety)
            fs.copyFileSync(localAssetPath, publicPath);

            imgUrl = `/generated_assets/${projectSlug}/${safeName}`;
        } else {
            console.log(`[Asset Missing] Fallback for: ${safeName}`);
            // Fallback
            imgUrl = `https://placehold.co/1080x1920/222222/FFFFFF/png?text=${encodeURIComponent(keyword)}`;
        }

        scenes.push({
            text: s.text,
            imageUrl: imgUrl,
            highlight: s.highlight || [],
            durationInFrames: duration
        });
    }

    // Calc Total Duration
    const lastCaption = captions[captions.length - 1];
    const totalDuration = (lastCaption.endMs / 1000 * 30) + 15; // +0.5s buffer

    // Construct Final Data
    const finalData = {
        audioUrl: audioUrl,
        captions: captions,
        scenes: scenes,
        titleSplit: scriptData.title_split,
        durationInFrames: Math.ceil(totalDuration)
    };

    fs.writeFileSync(outputFile, JSON.stringify(finalData, null, 2));
    console.log(`Saved data.json to ${outputFile}`);

    // Update public/data.json for Preview
    fs.writeFileSync(path.join(process.cwd(), 'public', 'data.json'), JSON.stringify(finalData, null, 2));
    console.log("Updated public/data.json for preview.");
}

main();
